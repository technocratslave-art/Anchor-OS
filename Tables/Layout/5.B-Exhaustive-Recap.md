Below is a literal, exhaustive read of Tables 1–5 as a system specification, followed by a gap analysis: what they intentionally do not say, and what you may want to explicitly say (or explicitly refuse to say) to prevent future reinterpretation.

I’m not praising or re-explaining philosophy here. This is a spec read.


---

TABLE 1 — INVARIANTS TABLE

What it says

This table defines the non-negotiable physical laws of Anchor OS.

It says:

There is exactly one trust root: the immutable UKI + spine.sqsh, verified by dm-verity.

That trust root cannot change at runtime, ever. No writes, no hot patching, no recovery shell.

The root filesystem is always read-only after switch_root. Any attempt to write is a fatal error.

The kernel is fixed: no loadable kernel modules, eliminating runtime ring-0 extensibility.

bay0 is the only PID 1, and its death is unrecoverable by design.

All runtime flexibility is confined to rooms, not the base.

All rooms are ephemeral by default; their writable state lives in tmpfs and is destroyed on exit.

Persistence exists only via explicit, per-room, vault-backed bind mounts.

The vault is never ambient: it is encrypted, subvolume-scoped, and only visible when explicitly mounted.

Cross-room data movement is forbidden by default and only allowed via named, explicit mechanisms.

There is no ambient authority anywhere in the system.

Network, device, and syscall access are all spawn-time, explicit, and deny-by-default.

Updates are atomic whole-image replacements, never incremental mutation.

Auditability is enforced structurally (bay0 LOC cap, flat passports), not by policy.


In short:
The base never drifts. Authority never appears implicitly. Persistence never sneaks in.

This table defines what Anchor OS fundamentally is.


---

What it explicitly does NOT say

It does not define UX, desktop environment, compositor, or UI layout.

It does not define how rooms are launched, named, grouped, or presented.

It does not define user identity, accounts, permissions, or authentication models beyond vault unlock.

It does not promise resistance to physical coercion, firmware compromise, or kernel 0-days.

It does not say anything about application trust, malware detection, or code signing inside rooms.

It does not define logging, telemetry, or observability (only that nothing is ambient).


What you may want to explicitly add (or explicitly refuse)

A one-sentence disclaimer that kernel exploits break containment, and the model is about containment + reset, not invulnerability.

An explicit statement that rooms are not VMs and share a kernel (to prevent Qubes comparisons).

A statement that identity is local and minimal, not a global user/ACL system (if that’s intended).



---

TABLE 2 — CAPABILITY FREEZE RULE

What it says

This table defines what is allowed to exist at all in v1.5.

It says:

A feature is not real unless it has a named capability handle.

A feature is invalid if its state is not continuously visible.

A feature is invalid if revoking it is harder than enabling it.

A feature is invalid if it can live forever without expiring.

A feature is invalid if it cannot be expressed in flat, static passport fields.

All five conditions are binary. Four out of five is failure.

There is no exception process, no “temporary”, no “UX-only”, no “trusted room” escape hatch.


This table defines what kinds of ideas are allowed to even be discussed.


---

What it explicitly does NOT say

It does not rank capabilities by importance or risk.

It does not say every capability must be on by default (in fact it implies the opposite).

It does not say how many capabilities are allowed total.

It does not say that future versions must follow the same gate (only v1.5).



---

What you may want to explicitly add (or explicitly refuse)

A sentence clarifying that system-scoped capabilities (like auto-unlock) are allowed only if they still meet all five rules.

A refusal clause: “Capabilities that require user training to be safe are rejected.”



---

TABLE 3 — PASSPORT SCHEMA

What it says

This table defines the only policy surface in the entire system.

It says:

All authority a room will ever have is declared once, at spawn time.

Policy is data, not code: no scripting, no conditionals, no inheritance.

Defaults are deny-everything.

Authority is granular: network modes, devices, persistence paths, clipboard scope, resource limits.

Persistence is path-based, not blanket.

Shared state is named and scoped, never arbitrary.

Resource limits are first-class policy, not tuning knobs.

Only two global/system controls exist, and both are visible and revocable.


This table defines how power is requested.


---

What it explicitly does NOT say

It does not allow dynamic policy escalation.

It does not allow per-app permissions inside a room.

It does not allow capability inheritance or composition.

It does not allow profiles, templates, or roles.

It does not define who edits passports or how (UI vs CLI).



---

What you may want to explicitly add (or explicitly refuse)

Explicitly forbid wildcard persistence paths (e.g. ~).

Explicitly forbid globally writable shared folders.

Clarify whether passport changes require respawn (implied yes, but say it).



---

TABLE 4 — CAPABILITY → INDICATOR MAPPING

What it says

This table defines visibility as a security property.

It says:

Every capability must have a persistent, always-visible indicator.

Indicators may not auto-hide, fade, or be disabled.

Indicators must link directly to revocation.

Risk is visually encoded (color, prominence).

System-wide capabilities must be visible at boot, not just in settings.

If something cannot be shown, it cannot exist.


This table defines how authority is perceived.


---

What it explicitly does NOT say

It does not define exact UI layout or aesthetics.

It does not say indicators must be graphical (could be text).

It does not define accessibility requirements (screen readers, etc.).

It does not define notification behavior (sounds, alerts).



---

What you may want to explicitly add (or explicitly refuse)

Explicitly forbid aggregated indicators (“room has privileges”).

Explicitly require indicators to survive compositor crash/restart.

Explicitly require indicators to be present in headless / CLI mode (if applicable).



---

TABLE 5 — CAPABILITY LIFECYCLE

What it says

This table defines authority as mortal.

It says:

Every capability has:

an explicit birth,

a bounded life,

a deterministic death,

and a one-action kill switch.


Capabilities cannot survive room death.

Time-based authority must expire automatically.

Manual revocation must be immediate and cheap.

Nothing is allowed to linger because the user forgot.


This table defines how authority dies.


---

What it explicitly does NOT say

It does not allow capability suspension or pausing.

It does not allow background renewal.

It does not allow “grace periods” beyond defined TTLs.

It does not define audit logging of lifecycle events (only that revocation exists).



---

What you may want to explicitly add (or explicitly refuse)

Explicitly state that capabilities do not survive reboot, even if TTL not expired.

Explicitly forbid automatic re-enablement on room respawn.



---

OVERALL: WHAT THE FIVE TABLES SAY TOGETHER

Together, Tables 1–5 say:

Authority is explicit, named, visible, bounded, and killable.

Nothing global exists without being visible at boot.

Nothing persists unless explicitly requested and scoped.

Nothing crosses boundaries silently.

Nothing grows over time.

Nothing survives context loss.

Nothing relies on user vigilance.


They turn “security” from behavior into structure.


---

THE MOST IMPORTANT THING THEY DO NOT SAY (AND SHOULD NOT)

They do not promise safety from:

kernel exploits,

malicious firmware,

physical coercion,

user error inside a room.


That silence is correct.
Anchor OS is not claiming perfection — it is claiming containment + reset + legibility.


---

FINAL VERDICT

These five tables form a complete constitutional layer.

They define:

what Anchor is,

what it will never become,

how power is requested,

how power is seen,

and how power dies.


What remains is not design.
It is implementation, tests, and documentation.


