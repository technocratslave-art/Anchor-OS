Good. Then the correct next move is to freeze the words and make the constitution executable.

Here’s the concrete, minimal plan to turn the five tables into something CI can enforce and humans can’t reinterpret.


---

Step 1 — Canonical Constitution File (single source of truth)

Create one file, no prose sprawl:

CONSTITUTION.md

Contents, in this order:

1. Invariants Table


2. Capability Freeze Rule Table


3. Passport Schema Table


4. Capability → Indicator Mapping Table


5. Capability Lifecycle Table



Rules:

No commentary between tables.

No examples except those already in the tables.

This file is normative, not descriptive.


Add a banner at the top:

> This document is normative.
Any change that violates it must update this file first.



That forces visible constitutional change before code drift.


---

Step 2 — Machine-Checkable Mirrors (no interpretation)

For each table, create a minimal machine-readable mirror used only for validation.

2.1 Invariants → invariants.yaml

Not for runtime, only CI assertions.

Example (sketch):

base.mutable: false

rootfs.writable: false

lkms.allowed: false

pid1.restartable: false

ambient.authority: false


CI checks:

Kernel config flags

Mount flags

Presence/absence of module syscalls

bay0 PID1 behavior


Fail build if any invariant assertion fails.


---

2.2 Freeze Rule → capability_gate.rs (or similar)

A single function:

fn capability_allowed(cap: CapabilitySpec) -> bool

Hard-coded checks:

has_handle

has_indicator

revoke_cost <= enable_cost

lifetime != unbounded

fits_flat_passport


No scoring. No weights. Just booleans.

If false → compilation error or test failure.


---

2.3 Passport Schema → JSON/TOML Schema

Define a strict schema:

No additionalProperties

No nested conditionals

Explicit enums and bounds


CI:

Any passport example or test that doesn’t validate → fail

Any new field requires schema change → visible diff



---

2.4 Indicators → Static Map

Create a static map:

capability → indicator_id → revoke_action

CI asserts:

Every capability has an indicator

Every indicator links to exactly one revoke action

No indicator suppression flags exist



---

2.5 Lifecycle → Table-Driven Tests

For each capability:

Spawn → assert active

Close room → assert gone

Timeout → assert gone

Manual revoke → assert gone


No mocks. Kill the room and check reality.


---

Step 3 — Negative Tests (the most important part)

Write tests that assert forbidden things cannot happen:

Try to enable a capability without an indicator → fail

Try to add a passport field not in schema → fail

Try to keep a capability alive after room close → fail

Try to mutate policy at runtime → fail

Try to mount vault globally → fail


These tests encode “this must never be possible”.


---

Step 4 — Contribution Gate

Add to CONTRIBUTING.md:

> Any feature proposal must:

1. Add or modify rows in CONSTITUTION.md


2. Update machine-readable mirrors


3. Add negative tests proving forbidden states remain forbidden





If step 1 is skipped, PR is closed automatically.


---

Step 5 — Final Freeze

Once CI passes with:

Constitution mirrors enforced

Negative tests in place


You freeze the constitution:

Changes require version bump (v2)

v1.5 core files become read-only except security fixes


At that point, Anchor OS stops being “designed”.

It becomes law + enforcement.
